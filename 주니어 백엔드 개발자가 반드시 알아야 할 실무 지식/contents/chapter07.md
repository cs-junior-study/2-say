<img width="1605" height="728" alt="image" src="https://github.com/user-attachments/assets/9745af30-0361-41f6-adc8-4546dbbf5bde" />
# 7장  IO 병목, 어떻게 해결하지

생성일: 2025년 7월 31일 오후 10:35

<br><br>

## 네트워크 IO와 자원 효율

<br>

트래픽이 증가하면 다음 2가지 이유로 자원 효율이 떨어지게 된다.

- IO 대기와 컨텍스트 스위칭에 따른 CPU 낭비
- 요청마다 스레드를 할당함으로써 메모리 사용량이 높음

이런 상황은 트래픽이 몰리는 인기 있는 서비스만 일어난다.

<br>


성능을 높이는 또 다른 방법은 자원 효율을 높이는 것이다. IO 대기로 인한 CPU 낭비를 줄이고 요청을 처리하는 데 필요한 메모리를 줄이는 것이다. 

<br><br>


(아래는 최적화를 마치고 최후로 고려할 사항이다.)

- 가상 스레드나 고루틴 같은 경량 스레드 사용
- 논블로킹 또는 비동기 IO 사용


<br><br>

## 가상 스레드로 자원 효율 높이기

<br>

자바의 가상 스레드나 GO 언어의 고루틴을 사용하면 성능을 높일 수 있다.

언어는 다르지만, 가상 스레드와 고루틴은 경량(light weight)스레드라는 공통점을 갖는다. JVM이 관리하는 스레드이다. 

마치 OS가 CPU로 실행할 스레드를 스케줄링하듯, 언어 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.

<br><br>
 

<img width="1232" height="786" alt="image" src="https://github.com/user-attachments/assets/08ff23f8-0696-4cb2-b0e1-b1e22526d81b" />

<br> 

가상 스레드를 경량 스레드라고 부르는 이유는 플랫폼 스레드보다 더 적은 자원을 사용하기 때문이다. 

플랫폼 스레드가 1만개를 만드는데 10,000M가 필요하다고 가정하면, 가상 스레드는 하나 당 약 2KB로 1만 개를 생성하는데 20MB 정도. 생성하는 시간도 어마어마하게 차이남

<br> 

하나의 플랫폼 스레드가 여러 가상 스레드를 실행시킨다. 따라서, 플랫폼 스레드가 언마운트되면 가상 스레드는 실행을 멈춘다. 

<br> 

계속 계속 IO 블로킹을 받은 가상 스레드는 언마운트되고 다른 가상 스레드가 마운트되어 작업을 이어간다.

<br> <br> 

### 가상 스레드와 성능

<br> 

가상 스레드는 IO 중심 작업일 때 효과가 있다. (블로킹이기 때문)

<br> 

CPU 중심 작업에서 가상 스레드를 사용하면 오히려 성능이 나빠질 수 있다. 거의 대부분 블로킹 연산이 없어서, 오히려 계속 낭비된다. 

가상 스레드의 이점을 얻으려면 CPU 코어 수를 줄이거나 트래픽이 더 많아져야 한다.  안 그러면 낭비되는 스레드들이 많을 것이다.


<br> <br> 

### 가상 스레드의 중요한 장점

<br> 

코드를 크게 수정할 필요가 없음

<br> <br> 

## 논블로킹 IO로 성능 더 높이기

사용자가 폭발적으로 증가하면 어느 순간 경량 스레드로도 한계가 온다. 이때는 서버의 IO 구현 방식을 구조적으로 변경해야 한다.  바로 논블로킹 IO를 사용해야 하는 것이다.

<br> <br> 

### 논블로킹 IO 동작 개요

1. 실행 가능한 IO 연산 목록을 구한다. (실행 가능한 연산을 구할 때까지 대기)
2. 1에서 구한 IO 연산 목록을 차례대로 순회한다.
    1. 각 IO 연산을 처리한다.
3. 이 과정을 반복.

<br> 

계속해서 작업들 목록에서, 처리가능한 연산을 찾고 처리가능하면 처리시도!

<br> <br> 

<img width="1605" height="728" alt="image" src="https://github.com/user-attachments/assets/9178bfe2-0b82-4fa4-83a3-6040df4d7700" />

<br><br>

논블로킹 IO는 클라이언트 수에 상관없이 소수의 스레드를 사용한다. 따라서, 같은 메모리로 더 많은 클라이언트 연결을 처리할 수 있다.

논블로킹 IO는 채널들을 N개의 그룹으로 나누고, 각 그룹마다 스레드를 생성하는 것이다.

보통 CPU 개수만큼 그룹을 나누고 각 그룹마다 입출력을 처리할 스레드를 할당한다.

<br><br>


<img width="1342" height="691" alt="image" src="https://github.com/user-attachments/assets/a3faf5b0-67e7-4af6-8238-714608ec62b8" />

<br><br>

### 리액터 패턴

<br>

리액터(reactor) 패턴은 논블로킹 IO를 이용해서 구현할 때 사용하는 패턴 중 하나이다.

리액터 패턴은 동시에 들어오는 여러 이벤트를 처리하기 위한 이벤트 처리 방법이다.

크게 리액터와 핸들러 두 요소로 구성된다.

<br>

리액터는 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 알맞은 핸들러에 이벤트를 전달한다.

다음과 비슷한 형태를 가진다.

<br>

```java
While (isRunning) {
	List<Event> events = getEvents(); // 이벤트가 발생할 때까지 대기
	for (Event event : events) {
			Handler handler = getHandler(event); // 이벤트를 처리할 핸들러 구함
			handler.handle(event); // 이벤트를 처리함
	}
}
```

<br>

위 연산을 하는 것도 블로킹을 유발하는 것이기 때문에, 지연될 수 있다. 따라서, 이를 별도로 연산할 스레드를 실행한다.


<br>

```java
DisposableServer server = TcpServer.create()
		.port(7031)
		.doOnConnection(conn -> 
					conn.addHandlerFirst(new LineBasedFrameDecoder(1024)) // 줄 단위 읽기 처리
		)
		.handle((in, out) -> {
				return in.revceive()
									.asString()
									.doOnNext(line -> {
										log.info("received: {}", line);
									})
									.flatMap(line -> 
												out.sendString(Mono.just(line + "\n")) // 문자열 쓰기
									);
				})
				.bindNow();
```

<br>

리액터 네티를 사용하면 위 처럼 줄 단위로 데이터를 주고받는 에코 서버를 구현할 수 있다. 

논 블로킹 IO를 도입하면 블로킹 IO보다 성능이 20배 향상된다. 

<br><br>

### 언제 어떤 방법을 택할까?

다음을 검토하자

<br>

- 성능 문제가 있는가?
- 문제가 있다면 네트워크 IO 관련 성능 문제인가?
- 구현 변경이 가능한가?
