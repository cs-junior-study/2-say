
# 3장 성능을 좌우하는 DB 설계와 쿼리

생성일: 2025년 6월 26일 오후 8:22

<br><br>

만약, 서비스가 하루에 5,000개의 게시글이 등록될 경우 약 6년이면 1,000만 건이 쌓인다.

사용자가 게시글을 찾기 위해서 전체 게시글을 찾는다면, 1,000만 건의 데이터를 비교해야한다.

따라서, 조건을 비교하는 컬럼에 index를 적절하게 설정해야한다.

<br><br>

<aside>
📝

하지만, %검색어% 같은 like 조건은 풀 스캔을 유발한다. 따라서, 엘라스틱서치나, DB에서 제공하는 전문 검색 기능을 사용해야한다. 

</aside>

<br><br><br>

### 단일 인덱스와 복합 인덱스

<br>

```sql
SELECT * FROM activityLog WHERE userID = 123 and activityDate = '2024-07-31'
ORDER BY activityDatetime desc
```

여기서 인덱스가 필요한데

<br>

- 단일 인덱스 : userId만
- 복합 인덱스 : userId, activityDate

만약 활동성이 좋지 않으면(1주일 한 번 정도 방문)인덱스를 사용하지 않아도 문제는 없다. 

<br>

하지만, 매일 30번 이상 활동을 한다면, 1년이면 1만 건이 넘는 activityDate를 남기게 된다. 따라서, 복합 인덱스를 설정해야 조회 성능 문제가 발생하지 않는다.

만약, 실시간으로 응답해야하는 쿼리가 아니고 통계적으로 하루에 한번만 실행하는 쿼리라면 인덱스를 굳이 설정할 필요가 없다. → 서비스가 너무 크다면 제외

<br><br>

### 선택도를 고려한 인덱스 컬럼 선택

인덱스를 고려할 땐 선택도가 낮은 컬럼을 설정하자. 고유한 값이 낮은 컬럼을 의미한다.

ex) 전체 컬럼 값들을 고려해도 3가지 일 때 W(대기), P(대기), C(완료)

<br><br>

### 커버링 인덱스 활용하기

- 커버링 인덱스는 특정 쿼리를 실행하는 데 필요한 컬럼을 모두 포함하는 인덱스를 말한다.

<br><br>

### 인덱스는 필요한 만큼만 만들기

```sql
SELECT * FROM activityLog WHERE userId = 123 AND activityDate = '2024-07-31'
ORDER BY activityDatetime desc;

SELECT * FROM activityDate = '2024-07-31' AND activityType = 'BUY' ORDER BY 
activityDatetime desc;
```

<br>

이렇게 두 쿼리가 있을 때, 두 번째 쿼리를 위해서 복합 쿼리를 고려할 때, 데이터 수가 많지 않다면 오히려 성능이 저하될 수 있다.

그런 상황에서는 요구사항을 일부 변경할 수 있는지 → 이미 설정되어 있는 인덱스를 탈 수 있는 지 고려해보자.

불필요한 인덱스를 추가한다면 기존 인덱스가 더 느려질 수 있음

<br><br><br>

### 미리 집계하기

```sql
select s.idm s.subject
(select count(*) from answer a where a.surveyId = s.id) as answerCnt,
(select count(*) from liked l where l.surveyId = s.id) as likeCnt
from survey s
order by id desc
limit 30;
```

<br>

해당 쿼리는 만약 survey 개수 만큼 서브 쿼리가 실행된다.

해당 Count, sum과 같은 집계 쿼리를 미리 계산하고 컬럼에 저장하는 식으로 변경해보자

<br>

```sql
update survey set answerCnt + 1 where surveyId = 아이디;
```

<br>

데이터를 추가하고 위 쿼리로 카운트만 증가시키면 된다.

but, 동시성 문제 조심


<br><br>

### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용

- Limit를 사용하면 다시 ID를 다 세고 나서 데이터를 조회하므로 느리다.
- 여기에서 인덱싱을 하지않은 where문을 실행한다면 더 오래 걸린다.
<br>

```sql
// 좋은 방법
SELECT * FROM article
WHERE id < 9985 and deleted = false
order by id desc
limit 10;
```

<br><br>

### 조회 범위를 시간 기준으로 제한하기

시간 범위 컬럼에 인덱스를 설정하고 범위를 선택하면 된다.

<br><br>


### 전체 개수 세지 않기

count 쿼리는 모든 데이터를 탐색해야 하기 때문에,  커버링 인덱스를 사용하더라도 전체 인덱스를 스캔해야한다. 커버링 인덱스가 아닌 경우에는 실제 데이터를 전부 읽어야한다.


<br><br><br>

### @

- 오래된 데이터 삭제하기
- DB 부하시 수평확장(CQRS) 수직확장
- 별도 캐시 서버 구성하기
- 쿼리 타임아웃 설정하기

<br><br>

### 상태 변경 기능은 복제 DB에서 조회하지 않기

SELECT 쿼리를 무조건 복제 DB에서 실행하는 경우가 있는데, 아래와 같은 문제가 발생할 수 있다.

<br>
- 주 DB와 복제 DB는 순간적으로 데이터가 일치하지 않을 수 있다. 주 DB에서 변경된 데이터는 다음 두 단계를 거쳐 복제 DB에 반영된다.
- 트랜잭션 문제가 발생할 수 있다. 주 DB와 복제 DB 간 데이터 복제는 트랜잭션 커밋 시점에 이뤄진다. 주 DB의 트랜잭션 범위 내에서 데이터를 변경하고, 복제 DB에서 변경 대상이 될 수 있는 데이터를 조회하면 데이터 불일치로 인해 문제가 생긴다.
<br>

따라서, INSERT, UPDATE, DELETE 쿼리를 실행하는 기능에서 변경 대상 데이터를 조회한다면, 

복제 DB가 아닌 주 DB에서 SELECT 쿼리를 실행하자. 그래야 데이터 불일치로 인해 발생할 수 있는 오류를 방지할 수 있다.


<br><br><br>

### 배치 쿼리 실행 시간 증가

집계 쿼리는 특성상 많은 데이터를 스캔한다. DB 사양을 높일 수 없다면 아래와 같은 대안이 있다.

- 커버링 인덱스 활용
- 데이터를 일정 크기로 나눠 처리


<br><br>


### @

- 타입이 다른 컬럼 조인 주의
- 테이블 변경은 신중하게 → 새 테이블을 생성하고 원본 테이블의 데이터 복사하고 대체하는 식으로 하기 때문
- DB 최대 연결 개수


<br><br>

### 트랜잭션을 잘 설정하자.

정합성 문제를 발생시킬 수 있다.

하지만, 회원가입 시 이메일 로직이 작동하지 않았다고 회원가입을 전체 취소해야할까?

필수로 묶여야할 단위 작업이 맞는지 확인하고 설정하자.
