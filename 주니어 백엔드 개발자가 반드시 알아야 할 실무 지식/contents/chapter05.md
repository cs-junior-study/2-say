# 5장 비동기 연동, 언제 어떻게 써야 할까

생성일: 2025년 7월 2일 오후 5:52

생각보다 많은 연동에서 비동기 방식을 사용해도 된다.

<br>

- 쇼핑몰에서 주문이 들어오면 판매자에게 푸시 보내기(푸시 서비스 연동)
- 학습을 완료하면 학생에게 포인트 지급(포인트 서비스 연동)
- 컨텐츠를 등록할 때 검색 서비스에도 등록(검색 서비스 연동)
- 인증 번호를 요청하면 SMS로 인증 메시지 발송(SMS 발송 서비스 연동)


<br><br>

비동기를 사용해도 되는 공통적인 특징은

<br>

- 연동에 약간의 시차가 생겨도 문제가 되지 않음
- 일부 기능을 실패했을 때 재시도가 가능하다.
- 연동에 실패했을 때, 나중에 수동으로 처리할 수 있는 기능이 있다.
- 연동에 실패했을 때 무시해도 되는 기능도 있다.

<br>
<br>

구현 방법은 크게 5가지

- 별도 스레드로 실행
- 메시지 시스템 사용
- 트랜잭션 아웃박스 패턴 사용
- 배치로 연동
- CDC 이용


<br><br>

### 별도 스레드로 실행하기

```java
ExecutorService executor = Excutors.newFixedThreadPool(50);

public OrderResult placeOrder(OrderRequest req) {
	 // 주문 생성 처리
	 
	 executor.submit(()-> pushClient.sendPush(pushData));
	 return successResult(...); //푸시 발송을 기다리지 않고 리턴
}
```

<br>

그 외에도 @Async 방법이 있다.


<br><br>

### 주의

```java
@Async
public void sendPushAsync(PushData pushData) {
		try {
			pushClient.sendPush(pushData);
		} catch(Exception e) {
			try {
				Thread.sleep(500);
			} catch(Exception ex) {}
			try {
				//재시도 하거나
				pushClient.sendPush(pushData);
			} catch(Exception e1) {
				// 실패를 로그로 남기거나
			}
		}
```

별도 스레드로 외부에서 실행하면 익셉션을 전파해도 소용없다. 코드 내부에서 발생한 오류를 직접 처리해야한다. 

<br><br>

### 메세지

- 두 시스템이 서로 영향을 주지 않는다는 점이다.


메시징 시스템을 사용하면 서비스 사이에서 중간 컴포넌트로써, 성능에 맞도록 메시지를 전달할 수 있다. 따라서, 각 서비스에 영향을 받지 않는다.

- 확장 용이

<br><br>

종류 → 각 장단점을 잘 파악하고 사용하자

- 레디스 pub/sub
- kafka
- rabbit mq

  <br><br>

### 메시지 생성 측 고려 사항

<br>

실패 시,

- 무시한다
- 재시도한다 → 중복 수신 방지 기능 필요
- 실패 로그 남긴다


<br><br>

주의

만약 주문 서비스에서 DB 변경은 실패했지만, 메시지 전송에 성공하여 알림을 보낸다면 고객에게 혼란을 줄 수 있다.

따라서, 해당 트랜잭션이 끝난 후 메시지를 pub할 수 있도록 로직을 수정해야한다.


<br>

<aside>
📝

글로벌 트랜잭션과 메시지 연동

여러 DB를 하나의 트랜잭션으로 묶어서 처리할 수도 있다. 이를 글로벌 트랜잭션이라고 한다.

글로벌 트랜잭션을 사용하면 여러 자원(여러 DB)에 대한 변경을 한 트랜잭션으로 묶어서 처리할 수 있다. 이런 방법이 2PC 방법으로 구현 되어있다.

따라서, 2단계 커밋을 처리하는 과정이 추가되면서 처리속도 느려진다.

메시지 유실 없이 보내고 싶다면 아웃박스 패턴을 검토하자.

</aside>

<br><br><br>

### 메시지 종류

<br>

이벤트 → 상태 변경

- 주문함
- 로그인에 실패함
- 상품 정보를 조회함
- 배송을 완료함

<br>

커맨드 → 무언가를 요청하는 메시지

<br>

- 포인트 지급하기
- 로그인 차단하기
- 배송 완료 문자 발송하기


<br><br><br>

### 트랜잭션 아웃박스 패턴

메시지 생성 시 고려 사항에서, 잘못된 메시지 발송을 막기 위해 DB 트랜잭션이 완료된 후 메시지를 전송하자는 내용을 언급했다. 하지만, 메시지 시스템 연동이 실패할 수도 있다. 

<br>

그렇다면 메시지 데이터를 DB에 보관하는 방식이 바로 트랜잭션 아웃박스 패턴의 핵심이다.


<br>

<img width="800" height="392" alt="image" src="https://github.com/user-attachments/assets/96b4c749-7a1e-4985-82d1-1a2fa4af9e6d" />


메시지 발송 완료 시,

<br>

- 데이터 베이스 테이블에서 발송을 완료했다면, 발송 상태 컬럼을 두어 발송 완료 상태로 변경할 수 있다.
- 전송한 마지막 ID 값을 기록하는 방식이다.

<br><br>

### 배치 전송

1. DB에서 전송할 데이터를 조회한다.
2. 조회한 결과를 파일로 기록한다.
3. 파일을 연동 시스템에 전송한다.

<br>

파일 형식은 csv, key-value, json 형태로 제공할 수 있다.

이름으로 인한 충돌이나, 시간을 고려하여 적절하게 판단해야함

DB, API를 통해 전달하는 방법도 있다.

<br>

### CDC (Change Data Capture)

<br><br>

변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴

<br><br>

상황에 따라 동일한 환경에 반영하는 것이 아니라면 가공하여 전달할 수 있다.

CQRS 패턴에서도 변경점을 확인 후, 데이터를 Command 명령으로 전달할 수 있다.

CDC를 사용해 메시지 시스템에 데이터를 전달하면 여러 시스템에 변경된 데이터를 전달할 수 있어 확장에 유리하다.

<br><br><br>


### CDC와 데이터 위치

CDC 처리기는 변경 데이터를 어디까지 처리했는지 기록해야 한다. 재시작할 때 마지막으로 조회한 로그부터 읽어올 수 있다.

<br>

복잡한 시스템에 연동 코드를 넣기 부담스러울 때, CDC를 유용하게 사용 가능.
